<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rocky vs Data Leaks â€” Defense</title>
<style>
  :root{
    --bg:#071428; --panel:#0b1f2c; --muted:#9fb9d6; --accent:#1f8bd6;
    --card:#0e2430; --text:#dff4ff;
  }
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,var(--bg),#041018);color:var(--text)}
  .wrap{display:flex;flex-direction:column;align-items:center;gap:12px;padding:16px;min-height:100%}
  header{width:100%;max-width:1080px;display:flex;justify-content:space-between;align-items:center}
  h1{font-size:1.1rem;margin:0}
  .top-controls{display:flex;gap:8px;align-items:center}
  button{background:var(--accent);border:none;color:white;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:600}
  button.secondary{background:#2b4a5a}
  .panel{background:linear-gradient(180deg,var(--panel),#072026);border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(0,0,0,0.5)}
  .gameRow{display:flex;gap:14px;align-items:flex-start}
  #gameWrap{background:linear-gradient(180deg,#021b27,#041018);padding:12px;border-radius:10px}
  canvas{display:block;border-radius:8px;background:linear-gradient(180deg,#07232b,#021018);box-shadow:0 10px 30px rgba(0,0,0,0.6)}
  .sidebar{width:280px;display:flex;flex-direction:column;gap:10px}
  .stat{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;background:var(--card);border-radius:8px;color:var(--muted)}
  .towers{display:flex;flex-direction:column;gap:8px}
  .towerBtn{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;background:#0f2d36;color:var(--text);cursor:pointer}
  .towerBtn.disabled{opacity:0.45;cursor:not-allowed}
  small{color:var(--muted)}
  footer{margin-top:6px;color:var(--muted);font-size:0.85rem}
  @media(max-width:900px){
    .gameRow{flex-direction:column;align-items:center}
    .sidebar{width:100%}
    canvas{width:100%;height:auto}
  }
</style>
</head>
<body>

<div class="wrap">
  <header style="max-width:1080px">
    <h1>Rocky vs Data Leaks â€” Defense</h1>
    <div class="top-controls">
      <div style="text-align:right" class="panel small">
        <div id="infoShards">Shards: 0</div>
        <div id="infoWave" style="font-size:0.92rem;color:var(--muted)">Wave: 0 | Lives: 10</div>
      </div>
      <button id="startWave">Start Wave</button>
      <button id="resetGame" class="secondary">Reset</button>
      <button id="shareBtn">Share Score</button>
    </div>
  </header>

  <div class="gameRow panel" style="max-width:1080px;width:100%">
    <div id="gameWrap">
      <canvas id="game" width="820" height="480"></canvas>
    </div>

    <div class="sidebar">
      <div class="stat panel"><div><strong id="bestWave">Best: 0</strong><br><small>Best wave survived</small></div><div></div></div>

      <div class="panel">
        <div style="font-weight:700;margin-bottom:8px">Towers</div>
        <div class="towers">
          <div class="towerBtn" data-type="encryptor" id="t_encryptor">
            <div><strong>Encryptor</strong><br><small>Focused DPS</small></div>
            <div style="text-align:right">Cost: <strong>50</strong></div>
          </div>
          <div class="towerBtn" data-type="firewall" id="t_firewall">
            <div><strong>Firewall</strong><br><small>Slow effect</small></div>
            <div style="text-align:right">Cost: <strong>70</strong></div>
          </div>
          <div class="towerBtn" data-type="obscurer" id="t_obscurer">
            <div><strong>Obscurer</strong><br><small>Area damage</small></div>
            <div style="text-align:right">Cost: <strong>90</strong></div>
          </div>
        </div>
        <small style="display:block;margin-top:8px;color:var(--muted)">Tap a tower, then tap a grid cell to place. Tap existing tower to upgrade (costs 75% base).</small>
      </div>

      <div class="panel">
        <div style="font-weight:700;margin-bottom:8px">Controls</div>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button id="sellBtn" class="secondary">Sell Mode</button>
          <button id="cancelBtn" class="secondary">Cancel</button>
        </div>
        <small style="display:block;margin-top:8px;color:var(--muted)">Selling returns 50% of tower base cost.</small>
      </div>

      <footer class="panel">
        <div style="font-size:0.95rem"><strong>Goal:</strong> Survive waves. Share your best wave with #SeismicRun</div>
      </footer>
    </div>
  </div>
</div>

<script>
(() => {
  // Canvas + grid setup
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const CELL = 64; // grid cell size
  const COLS = Math.floor(W / CELL);
  const ROWS = Math.floor(H / CELL);

  // Path (hardcoded path across the grid as list of cell centers)
  // We'll create a simple path from left edge to right edge zigzagging through rows.
  const pathCells = [];
  for (let c = 0; c < COLS; c++) {
    const r = Math.floor(ROWS/2) + ((c % 4 === 2) ? -1 : ((c % 4 === 0) ? 1 : 0));
    // clamp
    pathCells.push({c, r: Math.max(1, Math.min(ROWS-2, r))});
  }
  const path = pathCells.map(p => ({x: p.c*CELL + CELL/2, y: p.r*CELL + CELL/2}));

  // Game state
  let shards = Number(localStorage.getItem('rd_shards') || 120);
  let wave = Number(localStorage.getItem('rd_wave') || 0);
  let lives = Number(localStorage.getItem('rd_lives') || 10);
  let bestWave = Number(localStorage.getItem('rd_best') || 0);
  let enemies = [];
  let towers = []; // {cell:{c,r}, type, level, lastShot}
  let projectiles = [];
  let placing = null; // selected tower type for placing
  let sellMode = false;
  let runningWave = false;

  // Costs & stats
  const TOWERS = {
    encryptor: {cost:50, baseDmg:18, rate:650, range:120},
    firewall: {cost:70, baseDmg:6, rate:900, range:100, slow:0.45},
    obscurer: {cost:90, baseDmg:10, rate:1200, range:90, aoe:28}
  };

  // DOM refs
  const infoShards = document.getElementById('infoShards');
  const infoWave = document.getElementById('infoWave');
  const bestWaveEl = document.getElementById('bestWave');
  const startBtn = document.getElementById('startWave');
  const resetBtn = document.getElementById('resetGame');
  const shareBtn = document.getElementById('shareBtn');
  const sellBtn = document.getElementById('sellBtn');
  const cancelBtn = document.getElementById('cancelBtn');

  // tower buttons
  document.querySelectorAll('.towerBtn').forEach(el => {
    el.addEventListener('click', () => {
      const type = el.dataset.type;
      placing = type;
      sellMode = false;
      document.querySelectorAll('.towerBtn').forEach(x=>x.classList.remove('selected'));
      el.classList.add('selected');
    });
  });

  sellBtn.addEventListener('click', ()=>{ sellMode = !sellMode; placing = null; document.querySelectorAll('.towerBtn').forEach(x=>x.classList.remove('selected')); sellBtn.classList.toggle('active');});
  cancelBtn.addEventListener('click', ()=>{ placing = null; sellMode = false; document.querySelectorAll('.towerBtn').forEach(x=>x.classList.remove('selected')); });

  startBtn.addEventListener('click', () => {
    if (runningWave) return;
    wave++;
    runningWave = true;
    spawnWave(wave);
    saveState();
  });

  resetBtn.addEventListener('click', () => {
    if(!confirm('Reset game progress?')) return;
    shards = 120; wave = 0; lives = 10; enemies=[]; towers=[]; projectiles=[]; runningWave=false;
    bestWave = 0;
    saveState(true);
    updateHUD();
  });

  shareBtn.addEventListener('click', () => {
    const t = `I survived wave ${bestWave} in Rocky vs Data Leaks! Can you beat me? ðŸ”¹ @SeismicSys #SeismicRun`;
    navigator.clipboard.writeText(t).then(()=> alert('Tweet text copied to clipboard â€” paste it on X!'), ()=> alert('Copy failed, please copy manually:\n'+t));
  });

  // Save/load
  function saveState(forceClear=false){
    if(forceClear){
      localStorage.setItem('rd_shards', shards);
      localStorage.setItem('rd_wave', wave);
      localStorage.setItem('rd_lives', lives);
      localStorage.setItem('rd_best', bestWave);
    } else {
      localStorage.setItem('rd_shards', shards);
      localStorage.setItem('rd_wave', wave);
      localStorage.setItem('rd_lives', lives);
      localStorage.setItem('rd_best', bestWave);
    }
  }

  // Grid cell helpers
  function cellAtPixel(x,y){ return {c: Math.floor(x/CELL), r: Math.floor(y/CELL)}; }
  function cellCenter(c,r){ return {x: c*CELL + CELL/2, y: r*CELL + CELL/2}; }
  function cellKey(c,r){ return c + ',' + r; }
  function hasTower(c,r){ return towers.find(t => t.cell.c===c && t.cell.r===r); }

  // Placing and interacting
  canvas.addEventListener('pointerdown', (ev) => {
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * (canvas.width / rect.width);
    const y = (ev.clientY - rect.top) * (canvas.height / rect.height);
    const {c,r} = cellAtPixel(x,y);

    // disallow placing on path cells
    const onPath = path.some(p => Math.floor(p.x/CELL) === c && Math.floor(p.y/CELL) === r);
    // bounds
    if(c<0 || c>=COLS || r<0 || r>=ROWS) return;

    if (sellMode) {
      const existing = hasTower(c,r);
      if(existing){
        const refund = Math.floor(TOWERS[existing.type].cost * (0.5));
        shards += refund;
        towers = towers.filter(t => !(t.cell.c===c && t.cell.r===r));
        saveState();
      }
      updateHUD();
      return;
    }

    // tap existing tower to upgrade
    const existing = hasTower(c,r);
    if(existing){
      const upgradeCost = Math.floor(TOWERS[existing.type].cost * 0.75 * existing.level);
      if (shards >= upgradeCost) {
        shards -= upgradeCost;
        existing.level += 1;
        saveState();
        updateHUD();
      } else {
        // not enough
        flashMessage('Not enough shards to upgrade');
      }
      return;
    }

    if(placing){
      if(onPath){ flashMessage('Cannot place on path'); return; }
      const base = TOWERS[placing].cost;
      if(shards < base){ flashMessage('Not enough shards'); return; }
      shards -= base;
      towers.push({cell:{c,r}, type:placing, level:1, lastShot:0});
      placing = null;
      document.querySelectorAll('.towerBtn').forEach(x=>x.classList.remove('selected'));
      saveState();
      updateHUD();
    }
  });

  // spawn wave
  function spawnWave(n){
    const count = 5 + Math.floor(n * 1.6);
    const healthBase = 50 + Math.floor(n * 12);
    for(let i=0;i<count;i++){
      const hp = Math.floor(healthBase + Math.random()*n*10);
      const speed = 0.6 + Math.min(1.6, n*0.03) + Math.random()*0.4;
      setTimeout(()=> {
        enemies.push(createEnemy(hp, speed));
      }, i*600);
    }
  }

  function createEnemy(hp, speed){
    return {
      hp, maxHp:hp, speed, pos:0, // pos along path (float index)
      x: path[0].x, y: path[0].y, reached:false, slowed:1
    };
  }

  // game loop
  let last = Date.now();
  function loop(){
    const now = Date.now();
    const dt = (now - last);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function update(dt){
    // enemies movement
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      // progress by speed (scaled)
      e.pos += e.speed * (dt/16) * e.slowed;
      const idx = Math.floor(e.pos);
      if (idx >= path.length-1) {
        // reached end
        enemies.splice(i,1);
        lives -= 1;
        if(lives <= 0){ endGame(); return; }
        continue;
      } else {
        // interpolate position between path[idx] and path[idx+1]
        const t = e.pos - idx;
        const a = path[idx], b = path[idx+1];
        e.x = a.x + (b.x - a.x) * t;
        e.y = a.y + (b.y - a.y) * t;
      }
    }

    // towers act
    const nowMs = Date.now();
    towers.forEach(t => {
      const info = TOWERS[t.type];
      if (!info) return;
      if (nowMs - (t.lastShot||0) < (info.rate / (1 + (t.level-1)*0.12))) return;
      // find target enemy in range
      let target = null;
      let best = 999999;
      enemies.forEach(e => {
        const dx = e.x - (t.cell.c*CELL + CELL/2);
        const dy = e.y - (t.cell.r*CELL + CELL/2);
        const d2 = dx*dx + dy*dy;
        if (d2 < (info.range*info.range)) {
          // prefer closer to goal (higher pos)
          if(target === null || e.pos > best) { target = e; best = e.pos; }
        }
      });
      if (target){
        t.lastShot = nowMs;
        // do tower effect
        const damage = info.baseDmg * (1 + (t.level-1)*0.35);
        if (t.type === 'encryptor'){
          // single bullet
          projectiles.push({x: t.cell.c*CELL + CELL/2, y: t.cell.r*CELL + CELL/2, tx: target, dmg:damage, life:1200, type:'bullet'});
        } else if (t.type === 'firewall'){
          // apply slow
          target.slowed = 1 - (info.slow || 0);
          setTimeout(()=> { target.slowed = 1; }, 700 + t.level*100);
          target.hp -= damage * 0.6;
        } else if (t.type === 'obscurer'){
          // aoe: damage nearby enemies
          enemies.forEach(e2 => {
            const dx = e2.x - (t.cell.c*CELL + CELL/2);
            const dy = e2.y - (t.cell.r*CELL + CELL/2);
            if (dx*dx + dy*dy < (info.aoe*info.aoe)) {
              e2.hp -= damage * 0.9;
            }
          });
        }
      }
    });

    // projectile movement & hit detection
    for(let i=projectiles.length-1;i>=0;i--){
      const p = projectiles[i];
      if (p.type === 'bullet' && p.tx){
        // move toward target enemy current position
        const tx = p.tx.x, ty = p.tx.y;
        const dx = tx - p.x, dy = ty - p.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const sp = 8;
        if(dist < sp || !p.tx){ // hit
          if(p.tx && !p.tx.reached){
            p.tx.hp -= p.dmg;
          }
          projectiles.splice(i,1);
        } else {
          p.x += dx/dist*sp;
          p.y += dy/dist*sp;
        }
      } else {
        projectiles.splice(i,1);
      }
    }

    // remove dead enemies, give shards
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      if(e.hp <= 0){
        const reward = Math.max(5, Math.floor(e.maxHp/20));
        shards += reward;
        // small chance to drop extra
        if(Math.random() < 0.08) shards += 6;
        enemies.splice(i,1);
        // update best wave when wave cleared
      }
    }

    // if wave ongoing but all enemies cleared -> end wave
    if(runningWave && enemies.length === 0){
      runningWave = false;
      // update best
      if(wave > bestWave) { bestWave = wave; }
      saveState();
    }

    updateHUD();
  }

  function endGame(){
    // game over
    runningWave = false;
    if(wave > bestWave) bestWave = wave;
    alert('Game Over â€” you reached wave ' + wave + '. Best: ' + bestWave);
    // reset essentials but keep best and shards
    wave = 0; lives = 10; enemies=[]; towers=[]; projectiles=[];
    saveState(true);
    updateHUD();
  }

  function updateHUD(){
    infoShards.textContent = 'Shards: ' + Math.floor(shards);
    infoWave.textContent = 'Wave: ' + wave + ' | Lives: ' + lives;
    bestWaveEl.textContent = 'Best: ' + bestWave;
    // disable tower buttons if not enough shards
    document.querySelectorAll('.towerBtn').forEach(el => {
      const type = el.dataset.type;
      if (shards < TOWERS[type].cost) el.classList.add('disabled');
      else el.classList.remove('disabled');
    });
  }

  function flashMessage(txt){
    // small ephemeral toast (simple)
    const el = document.createElement('div');
    el.textContent = txt;
    el.style.position='fixed'; el.style.left='50%'; el.style.transform='translateX(-50%)';
    el.style.bottom='20px'; el.style.background='rgba(0,0,0,0.6)'; el.style.color='white';
    el.style.padding='8px 12px'; el.style.borderRadius='8px'; document.body.appendChild(el);
    setTimeout(()=> el.style.opacity = '0', 1200);
    setTimeout(()=> el.remove(), 1800);
  }

  // draw functions
  function drawGrid(){
    // draw cells
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const x = c*CELL, y = r*CELL;
        ctx.fillStyle = ( (c + r) % 2 === 0 ) ? '#041a20' : '#062025';
        ctx.fillRect(x,y,CELL,CELL);
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.strokeRect(x,y,CELL,CELL);
      }
    }
    // draw path
    ctx.beginPath();
    ctx.lineWidth = 12;
    ctx.strokeStyle = 'rgba(40,160,200,0.08)';
    ctx.lineJoin = 'round';
    for(let i=0;i<path.length;i++){
      const p = path[i];
      if(i===0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
  }

  function drawTowers(){
    towers.forEach(t=>{
      const center = cellCenter(t.cell.c,t.cell.r);
      ctx.save();
      // base circle
      ctx.beginPath();
      ctx.arc(center.x, center.y, 22, 0, Math.PI*2);
      ctx.fillStyle = (t.type==='encryptor')? '#9bd3ff' : (t.type==='firewall')? '#ffd9a8' : '#cfc9ff';
      ctx.fill();
      // inner mark for type
      ctx.fillStyle = '#072228'; ctx.font='bold 12px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(t.level, center.x, center.y+2);
      ctx.restore();
    });
  }

  function drawEnemies(){
    enemies.forEach(e=>{
      const cx = e.x, cy = e.y;
      // health bar
      ctx.fillStyle = '#0e0e0e';
      ctx.fillRect(cx-18, cy-28, 36, 6);
      const hpFrac = Math.max(0,e.hp)/e.maxHp;
      ctx.fillStyle = '#ff7a7a';
      ctx.fillRect(cx-18, cy-28, 36*hpFrac, 6);
      // body
      ctx.beginPath();
      ctx.arc(cx, cy, 12, 0, Math.PI*2);
      ctx.fillStyle = '#ffb199';
      ctx.fill();
      // small drip
      ctx.beginPath(); ctx.ellipse(cx, cy+16, 4,6,0,0,Math.PI*2); ctx.fillStyle = '#ff9074'; ctx.fill();
    });
  }

  function drawProjectiles(){
    projectiles.forEach(p => {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
      ctx.fillStyle = '#9be7ff';
      ctx.fill();
    });
  }

  function drawHUDOverlay(){
    // simple overlay text
    ctx.save();
    ctx.font='14px system-ui';
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillText('Rocky defends the Seismic network', 12, 18);
    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    drawGrid();
    drawTowers();
    drawEnemies();
    drawProjectiles();
    drawHUDOverlay();
  }

  // init
  updateHUD();
  loop();

  // animation: small periodic save & housekeeping
  setInterval(()=> {
    // passive shard gain if idle waves 0? keep small
    localStorage.setItem('rd_shards', shards);
    localStorage.setItem('rd_wave', wave);
    localStorage.setItem('rd_lives', lives);
    localStorage.setItem('rd_best', bestWave);
  }, 2000);

})();
</script>

</body>
</html>
